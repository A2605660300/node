<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>学习</title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/index.css" />
</head>

<body>
    <div onclick="cesi()">cs</div>
    <button id="btn">按钮</button>
</body>

<script type="text/javascript" src="js/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="js/index.js"></script>
<script>
    //------------------------------------------------------>
    // const arr = [1, 2, 3, 4]
    // //判断数组是否存在
    // console.log(arr.indexOf(1) >= 0)
    // console.log(arr.includes(1)) //es7新api
    // console.log(2 ** 3)
    // console.log(Math.pow(2, 3))


    //------------------------------------------------------>
    //async await 可以时停
    // async function f() {
    //     await Promise.reject('出错了');
    //     console.log(123) // 不会执行
    //     await Promise.resolve('hello world'); // 不会执行
    // }
    // f()

    //------------------------------------------------------>
    // function fn1() {
    //     return new Promise((res) => {
    //         setTimeout(() => {
    //             res('fn1')
    //         }, 2000)
    //     })
    // }

    // function fn2() {
    //     return new Promise((res) => {
    //         setTimeout(() => {
    //             res('fn2')
    //         }, 3000)
    //     })
    // }

    // //顺序执行
    // async function f() {
    //     console.time('f')
    //     await fn1();
    //     await fn2();
    //     console.timeEnd('f')
    // }
    // f()

    // //并行
    // async function f1() {
    //     console.time('f1')
    //     await Promise.all([fn1(), fn2()])
    //     console.timeEnd('f1')
    // }

    // //并行
    // async function f2() {
    //     console.time('f2')
    //     let fooPromise = fn1();
    //     let barPromise = fn2();
    //     let foo = await fooPromise;
    //     let bar = await barPromise;
    //     console.timeEnd('f2')
    // }
    // f1()
    // f2()

    //------------------------------------------------------>
    //Object.entries 遍历对象的键值
    // const obj = {
    //     name: null,
    //     age: '23'
    // }
    // if (obj.name == null) {
    //     delete obj.name
    // }

    // console.log(obj)
    // console.log(Object.entries(obj))
    // console.log(Object.entries('qwerty'))

    //------------------------------------------------------>
    //字符串操作
    // console.log('qwewqe'.padStart(8, '123')) //12qwewqe 头部拼接 第一个参数为增加后的长度，第二个为添加的字符串，长度不够自动截去添加的字符串 过短返回qwewqe 过长重复填充
    // console.log('qwewqe'.padEnd(8, '123')) //qwewqe12 尾部拼接 第一个参数为增加后的长度，第二个为添加的字符串，长度不够自动截去添加的字符串
    // console.log(Object.getOwnPropertyDescriptor(obj)) //对象描述

    // for (let val of obj) {
    //     console.log(val)
    // }

    // fn().then().catch().finally()

    // function fn1() {
    //     return new Promise((resolve, reject) => {
    //         resolve('对对对')
    //         // reject('错错错')
    //     })
    // }
    // fn1().then(res => {
    //     console.log(1234)
    // }).catch(err => {
    //     console.log(1235)
    // }).finally(res => {
    //     console.log(123)
    // })

    // function b() {

    // }

    // const toSlug = input => encodeURIComponent(
    //     input.split(' ')
    //     .map(str => str.toLowerCase())
    //     .join('-')
    // );

    // let obj = {
    //     '1': 1,
    //     '3': 3,
    //     '2': 2,
    //     4: 0.5,
    //     0: '',
    //     0.5: '',
    // }
    // console.log(Object.keys(obj))
    // console.log(Object.values(obj))

    // let nameer = '窗口'
    // let obj = {
    //     nameer: '对象',
    //     getn() {
    //         console.log(this.nameer)
    //     }
    // }
    // obj.getn()

    // console.log(('abc').toString())
    // console.log(toString({}))
    // console.log(toString.call('abc'))


    // const add = function (cb, t) {
    //     let boo = true;
    //     let time = +new Date();
    //     let timeoutid = null
    //     return function () {
    //         console.log(boo)
    //         if (boo) {
    //             cb();
    //             time = +new Date();
    //             boo = false
    //         } else {
    //             const dqtime = +new Date();
    //             timeoutid && clearTimeout(timeoutid)
    //             if (dqtime - time >= t) {
    //                 cb();
    //                 time = +new Date();
    //             } else {
    //                 const sytime = t - (+new Date() - time)
    //                 timeoutid = setTimeout(() => {
    //                     cb();
    //                     time = +new Date();
    //                 }, sytime)
    //             }
    //         }
    //     }
    // }

    // const myDebounce = (fn, wait = 500) => {

    //     // 缓存一个定时器
    //     let timer
    //     console.log(timer, 1)
    //     // 使用闭包（这样节流函数复用时，不会相互影响）
    //     return function (...args) {
    //         // 如果在500毫秒内再次触发，即timer存在，此时return，等待这个timer执行完毕。
    //         // 这里实现了时间间隔
    //         console.log(timer, 2)
    //         if (timer) return
    //         // 这里表示第一次触发，或是上一个timer执行完毕。就可以重新开启一个定时器。
    //         timer = setTimeout(() => {
    //             fn()
    //             timer = null
    //         }, wait)
    //     }
    // }

    // let log = function () {
    //     console.log('节流')
    // }

    // document.querySelector('#btn').onclick = add(log, 3000)

    var root = typeof self == 'object' && self.self === self && self ||
        typeof global == 'object' && global.global === global && global ||
        this || {};

    console.log(root)



    // var _ = function (obj) {
    //     if (obj instanceof _) return obj;
    //     if (!(this instanceof _)) return new _(obj);
    //     this._wrapped = obj;
    // };
</script>

</html>